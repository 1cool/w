{{ define "repository_entity" }}
package repository

import (
    "{{.Module }}/{{ .InternalDir }}/ent"
    "context"
)

type {{ .LowerCamelName }}Repository struct {
    client *ent.Client
}

// {{ .CamelName }}Repository is repository's functions used to service
// It statement the repository's abilities.
// the function name use Camel-Case define should be like this.
// the action is prefix the domain is middle and the other is suffix.
type {{ .CamelName }}Repository interface {
    Add{{ .CamelName }} (ctx context.Context, {{ .LowerCamelName }} ent.{{ .CamelName }}) (*ent.{{ .CamelName }}, error)
    Update{{ .CamelName }} (ctx context.Context, id int, {{ .LowerCamelName }} ent.{{ .CamelName }}) (int, error)
    List{{ .CamelName }} (ctx context.Context, offset, limit int) (int, []*ent.{{ .CamelName }}, error)
    Show{{ .CamelName }} (ctx context.Context, id int) (*ent.{{ .CamelName }}, error)
    Delete{{ .CamelName }} (ctx context.Context, id int) (int, error)

    // {{ .InjectInterface }}
}

func New{{ .CamelName }}Repository (client *ent.Client) {{ .CamelName }}Repository {
    return &{{ .LowerCamelName }}Repository{
        client: client,
    }
}

func (repo *{{ .LowerCamelName }}Repository) Add{{ .CamelName }} (ctx context.Context, {{ .LowerCamelName }} ent.{{ .CamelName }}) (*ent.{{ .CamelName }}, error) {
     return  repo.client.{{ .CamelName }}.Create().
             // TODO implement your business.
             Save(ctx)
 }

func (repo *{{ .LowerCamelName }}Repository) Update{{ .CamelName }} (ctx context.Context, id int, {{ .LowerCamelName | FirstLetter}} ent.{{ .CamelName }}) (int, error) {
     return repo.client.{{ .CamelName }}.Update().
             Where({{ .SnakeName }}.ID(id)).
             // TODO implement your business.
             Save(ctx)
}

func (repo *{{ .LowerCamelName }}Repository) List{{ .CamelName }} (ctx context.Context, offset, limit int) (int, []*ent.{{ .CamelName }}, error) {
     total, err := repo.client.{{ .CamelName }}.Query().Count(ctx)
     if err != nil {
         return 0, nil, err
     }

     list, err := repo.client.{{ .CamelName }}.Query().
         // TODO implement your business.
         Offset(offset).
         Limit(limit).
         All(ctx)

     if err != nil {
         return 0, nil, err
     }

     return  total, list, nil
}

func (repo *{{ .LowerCamelName }}Repository) Show{{ .CamelName }} (ctx context.Context, id int) (*ent.{{ .CamelName }}, error) {
     return repo.client.{{ .CamelName }}.Query().
         Where({{ .SnakeName }}.ID(id)).
         // TODO implement your business.
         First(ctx)
}

func (repo *{{ .LowerCamelName }}Repository) Delete{{ .CamelName }} (ctx context.Context, id int) (int, error) {
     return repo.client.{{ .CamelName }}.Delete().
         Where({{ .SnakeName }}.ID(id)).
         // TODO implement your business.
         Exec(ctx)
}

 // {{ .InjectHereImpl }}
{{ end }}

{{ define "repository_interface" }}
    New{{ .CamelName }}Repository() {{ .CamelName }}Repository
{{end}}

{{ define "repository_interface_impl" }}
    func (repo *repository) New{{ .CamelName }}Repository() {{ .CamelName }}Repository {
        return new{{ .CamelName }}Repository(repo.client)
    }
{{end}}