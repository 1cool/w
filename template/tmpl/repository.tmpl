{{ define "repository_entity" }}
package repository

import (
    "{{.Module }}/{{ .InternalDir }}/ent"
    "{{.Module }}/{{ .InternalDir }}/model"
    "context"
)

type {{ .LowerCamelName }}Repository struct {
    client *ent.Client
}

// {{ .CamelName }}Repository is repository's functions used to service
// It statement the repository's abilities.
// the function name use Camel-Case define should be like this.
// the action is prefix the domain is middle and the other is suffix.
type {{ .CamelName }}Repository interface {
    Add{{ .CamelName }} (ctx context.Context, {{ .LowerCamelName }} model.{{ .CamelName }}) (*model.{{ .CamelName }}, error)
    Update{{ .CamelName }} (ctx context.Context, id int, {{ .LowerCamelName }} model.{{ .CamelName }}) (int, error)
    List{{ .CamelName }} (ctx context.Context, offset, limit int) (int, []*model.{{ .CamelName }}, error)
    Show{{ .CamelName }} (ctx context.Context, id int) (*model.{{ .CamelName }}, error)
    Delete{{ .CamelName }} (ctx context.Context, id int) (int, error)

    // {{ .InjectInterface }}
}

func new{{ .CamelName }}Repository (client *ent.Client) {{ .CamelName }}Repository {
    return &{{ .LowerCamelName }}Repository{
        client: client,
    }
}

func (repo *{{ .LowerCamelName }}Repository) Add{{ .CamelName }} (ctx context.Context, {{ .LowerCamelName }} model.{{ .CamelName }}) (*model.{{ .CamelName }}, error) {
     _, err := repo.client.{{ .CamelName }}.Create().
             // TODO implement your business.
             Save(ctx)
     if err != nil {
        return nil, err
     }
     return &model.User{
        // TODO set you want filed from Save return value.
     }, err
 }

func (repo *{{ .LowerCamelName }}Repository) Update{{ .CamelName }} (ctx context.Context, id int, {{ .LowerCamelName | FirstLetter}} model.{{ .CamelName }}) (int, error) {
     return repo.client.{{ .CamelName }}.Update().
             Where({{ .SnakeName }}.ID(id)).
             // TODO implement your business.
             Save(ctx)
}

func (repo *{{ .LowerCamelName }}Repository) List{{ .CamelName }} (ctx context.Context, offset, limit int) (int, []*model.{{ .CamelName }}, error) {
     total, err := repo.client.{{ .CamelName }}.Query().Count(ctx)
     if err != nil {
         return 0, nil, err
     }

     var list []*model.{{ .CamelName }}
     err = repo.client.User.Query().
        // TODO implement your business.
        Offset(offset).
        Limit(limit).
        Select().
        Scan(ctx, &list)

     if err != nil {
        return 0, nil, err
     }
     return total, list, nil
}

func (repo *{{ .LowerCamelName }}Repository) Show{{ .CamelName }} (ctx context.Context, id int) (*model.{{ .CamelName }}, error) {
     var {{ .LowerCamelName | FirstLetter }} *model.{{ .CamelName }}
     err := repo.client.{{ .CamelName }}.Query().
         Where({{ .SnakeName }}.ID(id)).
         Select().
         // TODO implement your business.
         Scan(ctx, &{{ .LowerCamelName | FirstLetter }})
     if err != nil {
        return nil, err
     }
     return {{ .LowerCamelName | FirstLetter }}, nil
}

func (repo *{{ .LowerCamelName }}Repository) Delete{{ .CamelName }} (ctx context.Context, id int) (int, error) {
     return repo.client.{{ .CamelName }}.Delete().
         Where({{ .SnakeName }}.ID(id)).
         // TODO implement your business.
         Exec(ctx)
}

 // {{ .InjectInterfaceImpl }}
{{ end }}

{{ define "repository_interface" }}
    New{{ .CamelName }}Repository() {{ .CamelName }}Repository
    // {{ .InjectInterface }}
{{end}}

{{ define "repository_interface_impl" }}
func (repo *repository) New{{ .CamelName }}Repository() {{ .CamelName }}Repository {
    return new{{ .CamelName }}Repository(repo.client)
}

// {{ .InjectInterfaceImpl }}
{{end}}

{{ define "repository" }}
package repository

import (
    "{{ .InternalDir | ToSlash }}/ent"
)

type repository struct {
    client *ent.Client
}

// IRepository is repository's functions used to service
// It statement the repository's abilities.
// the function name use Camel-Case define should be like this.
// the action is prefix the domain is middle and the other is suffix.
type IRepository interface {
    // {{ .InjectInterface }}
}

func New(client *ent.Client) IRepository {
    return &repository{
        client: client,
    }
}

// {{ .InjectInterfaceImpl }}

{{ end }}